# 3211.生成不含相邻零的二进制字符串

给你一个正整数 `n`。

如果一个二进制字符串 `x` 的所有长度为 `2` 的**子字符串**中包含 **至少** 一个 `"1"`，则称 `x` 是一个 **有效** 字符串。

返回所有长度为 `n` 的 **有效** 字符串，可以以任意顺序排列。

**示例 1：**

```apach
输入： n = 3
输出： ["010","011","101","110","111"]
解释：
长度为 3 的有效字符串有："010"、"011"、"101"、"110" 和 "111"。
```

**示例 2：**

```apach
输入： n = 1
输出： ["0","1"]
解释：
长度为 1 的有效字符串有："0" 和 "1"。
```

**提示：**

- `1 <= n <= 18`

**解法一：** 回溯

```python
class Solution:
    def validStrings(self, n: int) -> List[str]:
        ans = []
        def dfs(lst):
            if len(lst) == n:
                ans.append(''.join(lst))
            else:
                if not lst or lst[-1] == '1':
                    lst.append('0')
                    dfs(lst)
                    lst.pop()
                lst.append('1')
                dfs(lst)
                lst.pop()
        
        dfs([])
        return ans
```

今天的每日一题，好久没做回溯的题了，难得来一道。
看到`n`的范围就知道，复杂度肯定是$2^n$。要求每个长度为2的子串至少有一个`'1'`，所以如果前一个字符是`0`，那么下一个就一定是`'1'`，而如果前一个是`'0'`的话，则无所谓。
所以写一个简单的`dfs`就行了，唯一需要注意的是，每次在函数中，每次`dfs`之后，要进行一次`pop`，使列表确保能回到之前的状态以进行回溯。
